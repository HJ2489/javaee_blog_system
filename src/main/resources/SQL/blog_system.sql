/*
 Navicat Premium Data Transfer

 Source Server         : 实验
 Source Server Type    : MySQL
 Source Server Version : 80029
 Source Host           : localhost:3306
 Source Schema         : blog_system

 Target Server Type    : MySQL
 Target Server Version : 80029
 File Encoding         : 65001

 Date: 04/06/2023 19:02:19
*/

SET NAMES utf8mb4;
SET FOREIGN_KEY_CHECKS = 0;

-- ----------------------------
-- Table structure for t_article
-- ----------------------------
DROP TABLE IF EXISTS `t_article`;
CREATE TABLE `t_article`  (
  `id` int(0) NOT NULL AUTO_INCREMENT,
  `title` varchar(50) CHARACTER SET utf8 COLLATE utf8_general_ci NOT NULL COMMENT '文章标题',
  `content` longtext CHARACTER SET utf8 COLLATE utf8_general_ci NULL COMMENT '文章具体内容',
  `created` date NOT NULL COMMENT '发表时间',
  `modified` date NULL DEFAULT NULL COMMENT '修改时间',
  `categories` varchar(200) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT '默认分类' COMMENT '文章分类',
  `tags` varchar(200) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT NULL COMMENT '文章标签',
  `allow_comment` tinyint(1) NOT NULL DEFAULT 1 COMMENT '是否允许评论',
  `thumbnail` varchar(200) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT NULL COMMENT '文章缩略图',
  PRIMARY KEY (`id`) USING BTREE
) ENGINE = InnoDB AUTO_INCREMENT = 9 CHARACTER SET = utf8 COLLATE = utf8_general_ci ROW_FORMAT = Dynamic;

-- ----------------------------
-- Records of t_article
-- ----------------------------
INSERT INTO `t_article` VALUES (1, '博客介绍', '  大家好，我是torch，欢迎来到我的博客！这里是我分享思考、见解和经验的地方。我喜欢写作，也喜欢和大家分享我的心路历程。在这个博客中，你可以看到我对个人成长、科技、文化、旅行和食物等各种主题的思考和见解。我相信，我们每个人都有自己独特的人生经历和成长历程，而通过分享和交流，我们可以彼此启发和激励，共同成长。\r\n\r\n  我的博客也是一个互动的平台，欢迎在评论区留下你的想法和反馈，我会认真回复每一个留言。如果你喜欢我的博客，也欢迎分享给更多的人。最后，感谢你的阅读，希望我们可以一起在这个平台上共同成长。', '2023-06-04', NULL, '默认分类', '介绍', 1, NULL);
INSERT INTO `t_article` VALUES (2, 'JDK 8——Lambda表达式介绍', '  Lambda表达式是JDK 8中一个重要的新特性，它使用一个清晰简洁的表达式来表达一个接口，同时Lambda表达式也简化了对集合以及数组数据的遍历、过滤和提取等操作。下面，本篇文章就对Lambda表达式进行简要介绍，并进行演示说明。\r\n\r\n**1. Lambda表达式入门**  \r\n\r\n  匿名内部类存在的一个问题是，如果匿名内部类的实现非常简单，例如只包含一个抽象方法的接口，那么匿名内部类的语法仍然显得比较冗余。为此，JDK 8中新增了一个特性Lambda表达式，这种表达式只针对有一个抽象方法的接口实现，以简洁的表达式形式实现接口功能来作为方法参数。  \r\n  一个Lambda表达式由三个部分组成，分别为参数列表、“->”和表达式主体，其语法格式如下：\r\n```js\r\n ([数据类型 参数名,数据类型 参数名,...]) -> {表达式主体}\r\n```  \r\n  从上述语法格式上看，Lambda表达式的书写非常简单，下面针对Lambda表达式的组成部分进行简单介绍，具体如下：  \r\n  （1）([数据类型 参数名,数据类型 参数名,...])：用来向表达式主体传递接口方法需要的参数，多个参数名中间必须用英文逗号“,”进行分隔；在编写Lambda表达式时，可以省略参数的数据类型，后面的表达式主体会自动进行校对和匹配；同时，如果只有一个参数，则可以省略括号“()”。  \r\n  （2）->：表示Lambda表达式箭牌，用来指定参数数据指向，不能省略，且必须用英文横线和大于号书写。  \r\n  （3）{表达式主体}：由单个表达式或语句块组成的主体，本质就是接口中抽象方法的具体实现，如果表达式主体只有一条语句，那么可以省略包含主体的大括号；另外，在Lambda表达式主体中允许有返回值，当只有一条return语句时，也可以省略return关键字。  \r\n  了解了Lambda表达式的语法后，接下来编写一个示例文件对Lambda表达式的基本使用进行介绍，具体代码如下所示。\r\n```js\r\n 1	// 定义动物类接口\r\n 2	interface Animal { \r\n 3		void shout(); // 定义方法shout()\r\n 4	}\r\n 5	public class Example22 {\r\n 6		public static void main(String[] args) {\r\n 7	       String name = \"小花\"; \r\n 8	       // 1、匿名内部类作为参数传递给animalShout()方法\r\n 9		  animalShout(new Animal() { \r\n 10				 public void shout() { \r\n 11				    System.out.println(\"匿名内部类输出：\"+name+\"喵喵...\");\r\n 12				}\r\n 13		  });\r\n 14		  // 2、使用Lambda表达式作为参数传递给animalShout()方法\r\n 15	       animalShout(()-> System.out.println(\"Lambda表达式输出：\"\r\n 16	                                                   +name+\"喵喵...\"));\r\n 17		}\r\n 18	    // 创建一个animalShout()静态方法，接收接口类型的参数\r\n 19		public static void animalShout(Animal an) {\r\n 20			an.shout();  \r\n 21		}\r\n 22	}\r\n```  \r\n  运行结果下图所示。\r\n![alt](/article_img/lambda/1.jpg)\r\n  上述代码示例中，先定义了只有一个抽象方法的接口Animal，然后分别使用匿名内部类和Lambda表达式的方式实现了接口方法。从图中可以看出，使用匿名内部类和Lambda表达式都能实现接口中方法，但很显然使用Lambda表达式更加简洁和清晰。', '2023-06-04', NULL, '默认分类', 'Lambda表达式', 1, NULL);
INSERT INTO `t_article` VALUES (3, '函数式接口', '&emsp;&emsp;虽然Lambda表达式可以实现匿名内部类的功能，但在使用时却有一个局限，即接口中有且只有一个抽象方法时才能使用Lamdba表达式代替匿名内部类。这是因为Lamdba表达式是基于函数式接口实现的，所谓函数式接口是指有且仅有一个抽象方法的接口，Lambda表达式就是Java中函数式编程的体现，只有确保接口中有且仅有一个抽象方法，Lambda表达式才能顺利地推导出所实现的这个接口中的方法。  \r\n&emsp;&emsp;在JDK 8中，专门为函数式接口引入了一个@FunctionalInterface注解，该注解只是显示的标注了接口是一个函数式接口，并强制编辑器进行更严格的检查，确保该接口是函数式接口，如果不是函数式接口，那么编译器就会报错，而对程序运行并没有实质上的影响。  \r\n&emsp;&emsp;接下来通过一个案例来演示函数式接口的定义与使用，示例代码如下所示。\r\n```js\r\n 1	// 定义无参、无返回值的函数式接口\r\n 2	@FunctionalInterface\r\n 3	interface Animal {\r\n 4		void shout();\r\n 5	}\r\n 6	// 定义有参、有返回值的函数式接口\r\n 7	interface Calculate {\r\n 8		int sum(int a, int b);\r\n 9	}\r\n 10	public class Example23 {\r\n 11		public static void main(String[] args) {\r\n 12		   // 分别两个函数式接口进行测试\r\n 13		   animalShout(() -> System.out.println(\"无参、无返回值的函数式接口调用\"));\r\n 14		   showSum(10, 20, (x, y) -> x + y);\r\n 15		}\r\n 16		// 创建一个动物叫的方法，并传入接口对象Animal作为参数\r\n 17		private static void animalShout(Animal animal) {\r\n 18			animal.shout();\r\n 19		}\r\n 20		// 创建一个求和的方法，并传入两个int类型以及接口Calculate类型的参数\r\n 21		private static void showSum(int x, int y, Calculate calculate) {\r\n 22		   System.out.println(x + \"+\" + y + \"的和为：\" + calculate.sum(x, y));\r\n 23		}\r\n 24	}\r\n```  \r\n&emsp;&emsp;运行结果如下图所示。\r\n\r\n![alt](/article_img/lambda/2.jpg)\r\n&emsp;&emsp;上述代码示例中，先定义了两个函数式接口Animal和Calculate，然后在测试类中分别编写了两个静态方法，并将这两个函数式接口以参数的形式传入，最后在main()方法中分别调用这两个静态方法，并将所需要的函数式接口参数以Lambda表达式的形式传入。从图中可以看出，程序中函数式接口的定义和使用完全正确。\r\n', '2023-06-04', NULL, '默认分类', '接口,函数式接口', 1, NULL);
INSERT INTO `t_article` VALUES (4, 'JDK 8——聚合操作', '&emsp;&emsp;在Java8版本中，JDK包含许多聚合操作（如平均值，总和，最小，最大，和计数），返回一个计算流stream的聚合结果。这些聚合操作被称为聚合操作。JDK除返回单个值的聚合操作外，还有很多聚合操作返回一个collection集合实例。很多的reduce操作执行特定的任务，如求平均值或按类别分组元素。  \r\n\r\n**1. 聚合操作简介**\r\n\r\n  在开发中，多数情况下会涉及到对集合、数组中元素的操作，在JDK 8之前都是通过普通的循环遍历出每一个元素，然后还会穿插一些if条件语句选择性的对元素进行查找、过滤、修改等操作，这种原始的操作方法虽然可行，但是代码量较大并且执行效率较低。  \r\n  为此，JDK 8中新增了一个Stream接口，该接口可以将集合、数组的中的元素转换为Stream流的形式，并结合Lambda表达式的优势来进一步简化集合、数组中元素的查找、过滤、转换等操作，这一新功能就是JDK 8中的聚合操作。  \r\n  在程序中，使用聚合操作没有绝对的语法规范，根据实际操作流程，主要可以分为以下3个步骤：  \r\n  （1）将原始集合或者数组对象转换为Stream流对象；  \r\n  （2）对Stream流对象中的元素进行一系列的过滤、查找等中间操作（Intermediate Operations），然后仍然返回一个Stream流对象；  \r\n  （3）对Stream流进行遍历、统计、收集等终结操作（Terminal Operation），获取想要的结果。  \r\n  接下来，就根据上面聚合操作的3个步骤，通过一个案例来演示聚合操作的基本用法，具体示例代码如下所示。\r\n```js\r\n 1	import java.util.*;\r\n 2	import java.util.stream.Stream;\r\n 3	public class Example31 {\r\n 4		public static void main(String[] args) {\r\n 5	          // 创建一个List集合对象\r\n 6			List<String> list = new ArrayList<>(); \r\n 7			list.add(\"张三\");\r\n 8			list.add(\"李四\");\r\n 9			list.add(\"张小明\");\r\n 10			list.add(\"张阳\");\r\n 11			// 1、创建一个Stream流对象\r\n 12			Stream<String> stream = list.stream();\r\n 13			// 2、对Stream流中的元素分别进行过滤、截取操作\r\n 14		       Stream<String> stream2 = stream.filter(i -> i.startsWith(\"张\"));\r\n 15			Stream<String> stream3 = stream2.limit(2);\r\n 16			// 3、对Stream流中的元素进行终结操作，进行遍历输出\r\n 17			stream3.forEach(j -> System.out.println(j));\r\n 18			System.out.println(\"=======\");\r\n 19	         // 通过链式表达式的形式完成聚合操作\r\n 20			list.stream().filter(i -> i.startsWith(\"张\"))\r\n 21						 .limit(2)\r\n 22						 .forEach(j -> System.out.println(j));\r\n 23		}\r\n 24	}\r\n``` \r\n   运行结果如下图所示。\r\n![alt](/article_img/lambda/3.jpg)\r\n  上述示例代码中，先创建了一个List集合，然后根据聚合操作的3个步骤实现了集合对象的聚合操作，对集合中的元素使用Stream流的形式进行过滤（filter）、截取（limit），并进行遍历输出。其中第12~17行代码分步骤详细展示了聚合操作，而第20~22行代码是使用了链式表达式（调用有返回值的方法时不获取返回值而是直接再调用另一个方法）实现了聚合操作，该表达式的语法格式更简洁、高效，这种链式调用也被称为操作管道流。\r\n\r\n**2. 创建Stream流对象**  \r\n  在上一小节中，介绍了聚合操作的主要使用步骤，其中首要解决的问题就是创建Stream流对象。聚合操作针对的就是可迭代数据进行的操作，如集合、数组等，所以创建Stream流对象其实就是将集合、数组等通过一些方法转换为Stream流对象。  \r\n  在Java中，集合对象有对应的集合类，可以通过集合类提供的静态方法创建Stream流对象，而数组数据却没有对应的数组类，所以必须通过其他方法创建Stream流对象。针对不同的源数据，Java提供了多种创建Stream流对象的方式，分别如下：  \r\n  （1）所有的Collections集合都可以使用stream()静态方法获取Stream流对象；  \r\n  （2）Stream接口的of()静态方法可以获取基本类型包装类数组、引用类型数组和单个元素的Stream流对象；  \r\n  （3）Arrays数组工具类的stream()静态方法也可以获取数组元素的Stream流对象。  \r\n  接下来，通过一个案例来学习聚合操作中如何创建Stream流对象，具体示例代码如下所示。\r\n```js\r\n 1	import java.util.*;\r\n 2	import java.util.stream.Stream;\r\n 3	public class Example32 {\r\n 4		public static void main(String[] args) {\r\n 5	          // 创建一个数组\r\n 6			Integer[] array = { 9, 8, 3, 5, 2 };       \r\n 7	          // 将数组转换为List集合\r\n 8			List<Integer> list = Arrays.asList(array); \r\n 9			// 1、使用集合对象的stream()静态方法创建Stream流对象\r\n 10			Stream<Integer> stream = list.stream();\r\n 11			stream.forEach(i -> System.out.print(i+\" \"));\r\n 12			System.out.println();\r\n 13			// 2、使用Stream接口的of()静态方法创建Stream流对象\r\n 14			Stream<Integer> stream2 = Stream.of(array);\r\n 15			stream2.forEach(i -> System.out.print(i+\" \"));\r\n 16			System.out.println();\r\n 17			// 3、使用Arrays数组工具类的stream()静态方法创建Stream流对象\r\n 18			Stream<Integer> stream3 = Arrays.stream(array);\r\n 19			stream3.forEach(i -> System.out.print(i+\" \"));\r\n 20		}\r\n 21	}\r\n```  \r\n  运行结果如下图所示。\r\n![alt](/article_img/lambda/4.jpg)\r\n  上述示例代码中，先创建了一个数组和一个集合，然后通过三种方式实现了Stream流对象的创建，并通过Stream流对象的forEach()方法结合Lambda表达式完成了集合和数组中元素的遍历。  \r\n\r\n**小提示：**  \r\n  在JDK 8中，只针对单列集合Collections接口对象提供了stream()静态方法获取Stream流对象，并未对Map集合提供相关方法获取Stream流对象，所以想要用Map集合创建Stream流对象必须先通过Map集合的keySet()、values()、entrySet()等方法将Map集合转换为单列Set集合，然后再使用单列集合的stream()静态方法获取对应键、值集合的Stream流对象。\r\n\r\n', '2023-06-04', NULL, '默认分类', 'JDK 8,聚合操作', 1, NULL);
INSERT INTO `t_article` VALUES (5, '虚拟化容器技术——Docker运行机制介绍', '  Docker是一个开源的应用容器引擎，它基于go语言开发，并遵从Apache2.0开源协议。使用Docker可以让开发者封装他们的应用以及依赖包到一个可移植的容器中，然后发布到任意的Linux机器上，也可以实现虚拟化。Docker容器完全使用沙箱机制，相互之间不会有任何接口，这保证了容器之间的安全性。  \r\n\r\n**1. Docker的引擎介绍**\r\n\r\n  Docker Engine（Docker引擎）是Docker的核心部分，使用的是客户端-服务器（C/S）架构模式，其主要组成部分如下图所示。\r\n![alt](/article_img/docker/1.png)\r\n  从上图可以看出，Docker Engine中包含了三个核心组件（docker CLI、REST API和docker daemon），这三个组件的具体说明如下：  \r\n  ①docker CLI（command line interface）：表示Docker命令行接口，开发者可以在命令行中使用Docker相关指令与Docker守护进程进行交互，从而管理诸如image（镜像）、container（容器）、network（网络）和data volumes（数据卷）等实体。  \r\n  ②REST API：表示应用程序API接口，开发者通过该API接口可以与Docker的守护进程进行交互，从而指示后台进行相关操作。  \r\n  ③docker daemon：表示Docker的服务端组件，他是Docker架构中运行在后台的一个守护进程，可以接收并处理来自命令行接口及API接口的指令，然后进行相应的后台操作。  \r\n  对于开发者而言，既可以使用编写好的脚本文件通过REST API来实现与Docker进程交互，又可以直接使用Docker相关指令通过命令行接口来与Docker进程交互，而其他一些Docker应用则是通过底层的API和CLI进行交互的。\r\n\r\n**2. Docker的架构介绍**\r\n\r\n  了解了Docker内部引擎及作用后，我们还需要通过Docker的具体架构，来了解Docker的整个运行流程。接下来借助Docker官网的架构图来对Docker架构进行详细说明，如下图所示。\r\n![alt](/article_img/docker/2.jpg)\r\n  从图中可以看出，Docker架构主要包括Client、DOCKER_HOST和Register三部分，关于这三部分的具体说明如下。  \r\n&emsp;&emsp;**（1）Client（客户端）**  \r\n  Client即Docker客户端，也就是上一小节Docker Engine中介绍的docker CLI。开发者通过这个客户端使用Docker的相关指令与Docker守护进程进行交互，从而进行Docker镜像的创建、拉取和运行等操作。  \r\n&emsp;&emsp;**（2）DOCKER_HOST（Docker主机）**  \r\n  DOCKER_HOST即Docker内部引擎运行的主机，主要指Docker daemon（Docker守护进程）。可以通过Docker守护进程与客户端还有Docker的镜像仓库Registry进行交互，从而管理Images（镜像）和Containers（容器）等。  \r\n&emsp;&emsp;**（3）Registry（注册中心）**  \r\n  Registry即Docker注册中心，实质就是Docker镜像仓库，默认使用的是Docker官方远程注册中心Docker Hub，也可以使用开发者搭建的本地仓库。Registry中包含了大量的镜像，这些镜像可以是官网基础镜像，也可以是其他开发者上传的镜像。  \r\n  我们在实际使用Docker时，除了会涉及到图中的三个主要部分外，还会涉及到很多Docker Objects（Docker对象），例如Images（镜像）、Containers（容器）、Networks（网络）、Volumes（数据卷）、Plugins（插件）等。其中常用的两个对象Image和Containers的说明如下。  \r\n  ①Images（镜像）  \r\n  Docker 镜像就是一个只读的模板，包含了一些创建Docker容器的操作指令。通常情况下，一个Docker镜像是基于另一个基础镜像创建的，并且新创建的镜像会额外包含一些功能配置。例如：开发者可以依赖于一个Ubuntu的基础镜像创建一个新镜像，并可以在新镜像中安装Apache等软件或其它应用程序。  \r\n  ②Containers（容器）  \r\n  Docker容器属于镜像的一个可运行实例（镜像与容器的关系其实与Java中的类与对象相似），开发者可以通过API接口或者CLI命令行接口来创建、运行、停止、移动、删除一个容器，也可以将一个容器连接到一个或多个网络中，将数据存储与容器进行关联。\r\n\r\n\r\n\r\n', '2023-06-04', NULL, '默认分类', '虚拟化容器,Docker,运行机制', 1, NULL);
INSERT INTO `t_article` VALUES (6, 'Docker常用客户端指令介绍', '  在使用Docker之前，首先会为对应的项目编写Dockerfile镜像构建文件，然后通过Docker的相关指令进行镜像构建，完成镜像的构建后，就可以使用这些项目镜像进行启动测试了。所以要想知道如何使用Docker来执行这些Dockerfile镜像构建文件，还需要学习Docker客户端的常用指令，本篇文章将对Docker客户端的常用指令进行详细讲解。  \r\n\r\n**1.列出镜像**  \r\n  通过docker images指令可以查看本地镜像列表中已有的镜像，具体使用方式如下。\r\n```js\r\n$ docker images\r\n```  \r\n  执行上述指令后，系统会将所有本地镜像都展示出来，如下图所示。\r\n![alt](/article_img/docker/3.png)\r\n  从图中可以看出，系统终端将本地镜像列表中的3个镜像分5列进行了展示，每一列的具体含义如下。  \r\n  ●REPOSITORY：镜像名称。  \r\n  ●TAG：镜像的参数，类似于版本号，默认是latest。  \r\n  ●IMAGE ID：镜像ID，是唯一值。此处看到的是一个长度为12的字符串，实际上它是64位完整镜像ID的缩写形式。  \r\n  ●CREATED：距今创建镜像的时间。  \r\n  ●SIZE：镜像大小。    \r\n\r\n**2.搜索镜像**  \r\n  想知道在Docker Hub中包含了哪些镜像，除了可以登录Docker Hub，在官网中心进行查看外，还可以直接在Docker客户端进行查询。例如想要查询Ubuntu镜像，可以使用如下指令。\r\n```js\r\n$ docker search ubuntu\r\n```  \r\n  执行上述指令后，系统终端就会将搜索到的有关Ubuntu的镜像展示出来，如下图所示。\r\n![alt](/article_img/docker/4.png)\r\n  从图所示的结果可以看出，系统终端分5列将搜索到的Ubuntu相关镜像都列举出来了，这5列的具体含义如下。  \r\n  ●NAME：表示镜像的名称，这里有两种格式的名称，其中不带有“/”的表示官方镜像，而带有“/”的表示其他用户的公开镜像。公开镜像“/”前面是用户在Docker Hub上的用户名（唯一），后面是对应的镜像名；官方镜像与用户镜像，除了从镜像名称上可以区分外，还可以通过第4列的OFFICIAL声明中看出（该列下内容为OK表示官方镜像）。  \r\n  ●DESCRIPTION：表示镜像的描述，这里只显示了一小部分。  \r\n  ●STARS：表示该镜像的收藏数，用户可以在Docker Hub上对镜像进行收藏，一般可以通过该数字反应出该镜像的受欢迎程度。  \r\n  ●OFFICIAL：表示是否为官方镜像。  \r\n  ●AUTOMATED：表示是否自动构建镜像。例如，用户可以将自己的Docker Hub绑定到如Github上，当代码提交更新后，可以自动构建镜像。   \r\n \r\n**3.拉取镜像**  \r\n  通过docker pull指令可以拉取仓库镜像到本地（默认都是拉取Docker Hub仓库镜像，也可以指定“IP+端口”拉取某个Docker机器上的私有仓库镜像），具体使用方式如下。\r\n```js\r\n$ docker pull ubuntu\r\n```  \r\n  执行上述指令后，Docker会自动从Docker Hub上下载最新版本的Ubuntu到本地，当然也可以使用以下指令拉取指定版本的镜像到本地，具体指令如下。\r\n```js\r\n$ docker pull ubuntu:14.04\r\n```  \r\n**4.构建镜像**  \r\n  除了可以通过docker pull指令从仓库拉取镜像外，还可以通过docker build指令构建Docker镜像，通常情况下都是通过Dockerfile文件来构建镜像的。  \r\n  这里假设linux系统home目录下/shitou/workspace/dockerspace文件夹中编写有对应的Dockerfile文件，则构建镜像直立示例如下所示。 \r\n```js\r\n$ docker build -t hellodocker3 /home/shitou/workspace/dockerspace/.\r\n```\r\n**5.删除镜像**  \r\n  当本地存放过多不需要的镜像时，可以通过docker rmi指令将其删除。在删除镜像时，需要指定镜像名称或镜像ID。删除镜像的使用方式如下。\r\n```js\r\n$ docker rmi -f hellodocker2 hellodocker3\r\n```  \r\n  上述指令中，docker rmi表示删除镜像，-f表示进行强制删除，而hellodocker2和hellodocker3分别表示需要删除的镜像名称，这里同时删除两个镜像。除了根据名称删除镜像外，还也可以根据镜像ID来删除镜像，只是这里如果指定了删除ID为23c617a866d4的镜像后，会同时删除hellodocker、hellodocker2和hellodocker3三个镜像。  \r\n  需要特别强调的是，在进行镜像删除操作时，如果是通过镜像ID进行镜像删除，那么由该镜像创建的容器必须提前删除或停止。另外，在通过镜像名称操作镜像时，如果出现镜像重名的情况，必须在镜像名称后面指定镜像标签tag参数来确保唯一性。\r\n\r\n**6.创建并启动容器**  \r\n  Docker镜像主要用于创建容器，可以使用docker run指令创建并启动容器，具体使用方式如下。\r\n```js\r\n$ docker run -d -p 5000:80 --name test hellodocker\r\n```  \r\n  上述创建并启动容器的指令略微复杂，具体分析如下。  \r\n  ●docker run：表示创建并启动一个容器，而后面的hellodocker就表示要启动运行的镜像名称；  \r\n  ●-d：表示容器启动时在后台运行；  \r\n  ●-p 5000:80：表示将容器内暴露的80端口映射到宿主机指定的5000端口，也可以将-p 5000:80更改为-P来映射主机的随机端口（注意p字母的大小写）；  \r\n  ●--name test：表示为创建后的容器指定名称为test，如果没有该参数配置，则生成的容器会设置一个随机名称。  \r\n  docker run命令是Docker操作中较为复杂的一个，它可以携带多个参数和参数，我们可以通过docker run --help指令进行查看，其中有些参数如-e、-v和-w等都可以在Dockerfile文件中预先声明。 \r\n \r\n**7.列出容器**  \r\n  生成容器后，可以通过docker ps指令查看当前运行的所有容器，具体使用方式如下。\r\n```js\r\n$ docker ps\r\n```  \r\n  执行上述命令后，会将所有当前运行的容器都展示出来，具体如下图所示。\r\n![alt](/article_img/docker/5.png)\r\n  从图中可以看出，系统终端通过7列对当前的正在运行的一个容器进行了展示，图中每一列的具体含义如下。  \r\n  ●CONTAINER ID：表示生成的容器ID；  \r\n  ●IMAGE：表示生成该容器的镜像名称；  \r\n  ●COMMAND：表示启动容器时运行的命令，Docker要求在启动容器时必须运行一个命令；  \r\n  ●CREATED：表示容器创建的时间；  \r\n  ●STATUS：表示容器运行状态，例如Up表示运行中，Exited表示已停止；  \r\n  ●PORTS：表示容器内部暴露的端口映射到主机的端口；  \r\n  ●NAMES：表示生成容器的名称，由Docker引擎自动生成，可以像上述示例中使用--name参数指定生成容器的名称。  \r\n  另外，docker ps指令运行过程中可以指定多个参数，还可以通过docker ps --help指令对ps指令的其他信息进行查看。\r\n\r\n**8.删除容器**  \r\n  当不需要使用容器时，则可以使用docker rm指令删除已停止的容器，具体使用方式如下。\r\n```js\r\n$ docker rm f0c9a8b6e8c5\r\n```  \r\n  需要注意的是，上述指令只能删除已经停止运行的容器，而不能删除正在运行的容器。如果想要删除正在运行的容器，则需要添加-f参数强制删除，具体使用方式如下。\r\n```js\r\n$ docker rm -f f0c9a8b6e8c5\r\n```  \r\n  当需要删除的容器过多时，如果还一个个的删除就略显麻烦了，此时可以通过如下指令将全部容器删除。\r\n```js\r\n$ docker rm -f $(docker ps -aq)\r\n```  \r\n  上述指令中，首先会通过$(docker ps -aq)获取所有容器的ID，然后通过docker rm -f指令进行强制删除。如果开发者有自己特殊的删除需求，可以根据前面docker ps指令进行组装来获取需要删除的容器ID。  \r\n  Docker提供的操作指令远不止这些，这里就不一一列举了，想要了解更多Docker的操作指令，可以通过docker --help指令进行查看。\r\n\r\n\r\n', '2023-06-04', NULL, '默认分类', 'Docker,客户端指令', 1, NULL);
INSERT INTO `t_article` VALUES (7, 'Docker数据管理介绍', '  当我们对容器进行相关操作时，产生的一系列数据都会存储在容器中，而Docker内部又是如果管理这些数据的呢？本篇文章将针对Docker数据管理的一些知识进行介绍。\r\n  \r\n**1. Docker数据存储机制**  \r\n  使用Docker时，我们操作的都是镜像和由镜像生成的容器，所以想要更好的了解Docker内部的数据存储机制，就必须从镜像、容器与数据存储的关系出发。  \r\n  Docker镜像是通过读取Dockerfile文件中的指令构建的，Dockerfile中的每条指令都会创建一个镜像层，并且每层都是只读的，这一系列的镜像层就构成了Docker镜像。接下来以一个Dockerfile文件为例进行说明，具体如下列代码示例所示。\r\n```js\r\n 1	FROM ubuntu:16.04\r\n 2	COPY . /app\r\n 3	RUN make /app\r\n 4	CMD python /app/app.py\r\n```  \r\n   上述文件示例中的Dockerfile包含了4条指令，每条指令都会创建一个镜像层，其中每一层与前一层都有所不同，并且是层层叠加的。通过镜像构建容器时，会在镜像层上增加一个容器层（即可写层），所有对容器的更改都会写入容器层，这也是Docker默认的数据存储方式。  \r\n  下面通过一个效果图进行说明，具体如下图所示。\r\n![alt](/article_img/docker/6.png)\r\n  从图中可以看出，Docker容器和镜像之间的主要区别是顶部的容器层，而所有对容器中数据的添加、修改等操作都会被存储在容器层中。当容器被删除时，容器层也会被删除，其中存储的数据会被一同删除，而下面的镜像层却保持不变。  \r\n  由于所有的容器都是通过镜像构建的，所以每个容器都有各自的容器层，对于容器数据的更改就会保存在各自的容器层中。也就是说，由同一个镜像构建的多个容器，它们会拥有相同的底部镜像层，而拥有不同的容器层，多个容器可以访问相同的镜像层，并且有自己的独立数据状态。具体说明如下图所示。 \r\n![alt](/article_img/docker/7.png)\r\n  从图中可以看出，基于同一个镜像构建的多个容器可以共享该镜像层，但是多个容器想要共享相同的数据，就需要将这些数据存储到容器之外的地方，而这种方式就是下一节要提到的Docker volume数据外部挂载机制。  \r\n\r\n**2. Docker数据存储方式**    \r\n  在默认情况下，Docker中的数据都是存放在容器层的，但是这样存储数据却有较多的缺陷，具体表现如下。    \r\n  ●当容器不再运行时，容器中的数据无法持久化保存，如果另一个进程需要这些数据，那么将很难从容器中获取数据；  \r\n  ●容器层与正在运行的主机紧密耦合，不能轻易地移动数据；  \r\n  ●容器层需要一个存储驱动程序来管理文件系统，存储驱动程序提供了一个使用Linux内核的联合文件系统，这种额外的抽象化降低了性能。  \r\n  基于上述种种原因，多数情况下Docker数据管理都不会直接将数据写入容器层，而是使用另一种叫做Docker volume数据外部挂载的机制进行数据管理。  \r\n  针对Docker volume数据外部挂载机制，Docker提供了三种不同的方式将数据从容器映射到Docker宿主机，他们分别为：volumes（数据卷）、bind mounts（绑定挂载）和tmpfs mounts（tmpfs挂载）。这三种数据管理方式的具体选择，需要结合实际情况进行考虑，其中的volumes数据卷是最常用也是官方推荐的数据管理方式。无论选择使用哪种数据管理方式，数据在容器内看起来都一样的，而在容器外则会被被挂载到文件系统中的某个目录或文件中。    \r\n  下面通过一张图来展示数据卷、绑定挂载和tmpfs挂载之间的差异，如下图所示。  \r\n![alt](/article_img/docker/8.png)\r\n  从图中可以看出，Docker提供的三种数据管理方式略有不同，具体分析如下。  \r\n  ●volumes：存储在主机文件系统中（在Linux系统下是存在于/var/lib/Docker/volumes/目录），并由Docker管理，非Docker进程无法修改文件系统的这个部分。  \r\n  ●bind mounts：可以存储在主机系统的任意位置，甚至可能是重要的系统文件或目录，在Docker主机或容器上的非Docker进程可以对他们进行任意修改。  \r\n  ●tmpfs mounts：只存储在主机系统的内存中，并没有写入到主机的文件系统中。\r\n\r\n\r\n', '2023-06-04', NULL, '默认分类', 'Docker,数据管理', 1, NULL);
INSERT INTO `t_article` VALUES (8, 'Spring Boot 2 权威发布', '  如果这两天登录 [https://start.spring.io/ ](https://start.spring.io/ )就会发现，Spring Boot 默认版本已经升到了 2.1.0。这是因为 Spring Boot 刚刚发布了 2.1.0 版本，我们来看下 Spring Boot 2 发布以来第一个子版本都发布了哪些内容？  \r\n\r\n**2.1 中的新特性**     \r\n  ●将spring-boot-starter-oauth2-oidc-client重命名为spring-boot-starter-oauth2-client命名更简洁  \r\n  ●添加 OAuth2 资源服务 starter，OAuth2 一个用于认证的组件  \r\n  ●支持 ConditionalOnBean 和 ConditionalOnMissingBean 下的参数化容器  \r\n  ●自动配置 applicationTaskExecutor bean 的延迟加载来避免不必要的日志记录  \r\n  ●将 DatabaseDriver＃SAP 重命名为 DatabaseDriver  \r\n  ●跳过重启器不仅适用于 JUnit4，也适用于 JUnit5  \r\n  ●在 Jest HealthIndicator 中使用集群端点  \r\n  ●当 DevTools 禁用重启时添加日志输出  \r\n  ●添加注解：@ConditionalOnMissingServletFilter提高 Servlet Filters 的自动装配。\r\n  \r\n**2.1 中的组件升级**  \r\n  ●升级 Hibernate 5.3，Hibernate 的支持升级到了 5.3  \r\n  ●升级 Tomcat 9 ，支持最新的 tomcat 9  \r\n  ●支持 Java 11，Java 现在更新越来越快，Spring 快赶不上了    \r\n  ●升级 Thymeleaf Extras Springsecurity 到 3.0.4.RELEASE ，thymeleaf-extras-springsecurity 是 Thymeleaf 提供集成 Spring Security 的组件  \r\n  ●升级 Joda Time 2.10.1，Joda-Time， 面向 Java 应用程序的日期/时间库的替代选择，Joda-Time 令时间和日期值变得易于管理、操作和理解。  \r\n  ●升级 Lettuce 5.1.2.RELEASE ，Lettuce 前面说过，传说中 Redis 最快的客户端。  \r\n  ●升级 Reactor Californium-SR2 ，Californium 是物联网云服务的 Java COAP 实现。因此，它更专注的是可扩展性和可用性而不是像嵌入式设备那样关注资源效率。不过，Californium 也适合嵌入式的 JVM。  \r\n  ●升级 Maven Failsafe Plugin 2.22.1 ，Maven 中的测试插件。  \r\n  ●升级 Flyway 5.2.1 ， Flyway是一款开源的数据库版本管理工具  \r\n  ●升级 Aspectj 1.9.2 ，AspectJ 是 Java 中流行的 AOP（Aspect-oriented Programming）编程扩展框架，是 Eclipse 托管给 Apache 基金会的一个开源项目。  \r\n  ●升级 Mysql 8.0.13 ，Mysql 支持到 8。  \r\n  ●...  \r\n&emsp;&emsp;更多的详细内容可以参考这里：[Spring Boot 2.1 Release Notes](https://github.com/spring-projects/spring-boot/wiki/Spring-Boot-2.1-Release-Notes)\r\n', '2023-06-04', NULL, '默认分类', 'Spring Boot 2', 1, NULL);
INSERT INTO `t_article` VALUES (9, 'github工作流', '<meta name=\"referrer\" content=\"no-referrer\" />\r\n\r\n\r\n### github工作流\r\n\r\n#### 一般流程\r\n\r\n1.先git clone远端仓库（remote）到本地。\r\n\r\n![](http://typora-imagehost.oss-cn-guangzhou.aliyuncs.com/img/image-20230328105321626.png)\r\n\r\n这里的disk是实际源文件，当git clone之后，local和disk的内容是一样的\r\n\r\n\r\n\r\n2.当需要修改代码时，先建立一个新的branch。\r\n\r\n建立新的branch，而不是直接往main上push代码的好处：\r\n\r\n- 不至于将主分支弄得无法工作\r\n- 利于多人合作\r\n\r\n`git checkout -b my-feature` (其中my-feature是branch的名字)\r\n\r\n这个命令会复制你的当前branch到新的branch上（clone之后，当前branch显然是main）\r\n\r\n作用：**创建并切换到新的分支**\r\n\r\ngit会把my-feature这个branch的代码同步到硬盘\r\n\r\n![](http://typora-imagehost.oss-cn-guangzhou.aliyuncs.com/img/image-20230328105758642.png)\r\n\r\n\r\n\r\n3.改好代码，保存文件之后。硬盘上的文件是有变化的，但是git不知道。\r\n\r\n使用命令查看硬盘上的文件与保存的分支的区别\r\n\r\n`git diff`\r\n\r\n![](http://typora-imagehost.oss-cn-guangzhou.aliyuncs.com/img/image-20230328110119165.png)\r\n\r\n\r\n\r\n4.将修改的文件告知git\r\n\r\n`git add <changed_file>` （后面是文件名）\r\n\r\n这些文件会放到暂存区中。\r\n\r\n![](http://typora-imagehost.oss-cn-guangzhou.aliyuncs.com/img/image-20230328110340728.png)\r\n\r\n\r\n\r\n5.将修改真正放到git中\r\n\r\n`git commit `\r\n\r\n![](http://typora-imagehost.oss-cn-guangzhou.aliyuncs.com/img/image-20230328110453653.png)\r\n\r\n\r\n\r\n6.将local git的变化告知github\r\n\r\n`git push origin my-feature`\r\n\r\n![](http://typora-imagehost.oss-cn-guangzhou.aliyuncs.com/img/image-20230328110601113.png)\r\n\r\n使用之后，会发现github中多出来了一个branch（my-feature）\r\n\r\n\r\n\r\n#### push之后main branch又有更新了\r\n\r\n需要把main branch的更新同步到my-feature这个branch里\r\n\r\n1.先更新local git的main（由于local git的main和remote的面是不一样的），切换到main这个branch中。\r\n\r\n`git checkout main`\r\n\r\n![](http://typora-imagehost.oss-cn-guangzhou.aliyuncs.com/img/image-20230328110847652.png)\r\n\r\n这时候硬盘里面的源代码是初始状态，而不是刚才修改了的状态。\r\n\r\n\r\n\r\n2.将远端的main同步到本地的main\r\n\r\n`git pull origin main `  (这里图片是master，看github的主分支是main还是master)\r\n\r\n![](http://typora-imagehost.oss-cn-guangzhou.aliyuncs.com/img/image-20230328111140255.png)\r\n\r\n这时local git和disk就会远端的github一样了\r\n\r\n\r\n\r\n3.回到my-feature branch中\r\n\r\n`git checkout my-feature`\r\n\r\n![](http://typora-imagehost.oss-cn-guangzhou.aliyuncs.com/img/image-20230328111425920.png)\r\n\r\n这时disk的my-feature有我们修改的f-commit的变化，但是没有远端main的update的变化\r\n\r\n\r\n\r\n4.同步main的代码改变\r\n\r\n`git rebase main` \r\n\r\n作用是：将自己的修改放到一边，把main最新的修改拿过来，然后在这个最新修改的基础上，将自己的commit尝试弄回去。\r\n\r\n![](http://typora-imagehost.oss-cn-guangzhou.aliyuncs.com/img/image-20230328111613063.png)\r\n\r\n这一过程可能出现rebase conflict，如果出现，则需手动选择需要哪一段代码。\r\n\r\n\r\n\r\n5.push 到github上\r\n\r\n`git push -f origin my-feature`  （由于做了rebase，在push的时候需要加-f，表示force，强行push）\r\n\r\n![](http://typora-imagehost.oss-cn-guangzhou.aliyuncs.com/img/image-20230328111941150.png)\r\n\r\n\r\n\r\n\r\n\r\n6.将更新的代码合并到main branch中（pull request）\r\n\r\n![](http://typora-imagehost.oss-cn-guangzhou.aliyuncs.com/img/image-20230328112114101.png)\r\n\r\n\r\n\r\n7.主分支的主人会对pull request进行squash and merge（意思是把这个分支上的所有改变合并成一个改变，然后把这个commit放到main branch上，这些改变合并之后是图中的update2）\r\n\r\n![](http://typora-imagehost.oss-cn-guangzhou.aliyuncs.com/img/image-20230328112309950.png)\r\n\r\n\r\n\r\n8.一般情况下，会将远端的branch（即my-feature）删掉（github上有一个delete branch的按钮）\r\n\r\n\r\n\r\n9.删除local git的branch删掉\r\n\r\n`git branch -D my-feature`\r\n\r\n![](http://typora-imagehost.oss-cn-guangzhou.aliyuncs.com/img/image-20230328112650677.png)\r\n\r\n\r\n\r\n10.将最新的更新拉到local的main branch和disk上\r\n\r\n`git pull origin main`\r\n\r\n![](http://typora-imagehost.oss-cn-guangzhou.aliyuncs.com/img/image-20230328112749713.png)\r\n\r\n这些操作后，local git 和disk又和remote一样了。\r\n\r\n#### 参考\r\n\r\n[参考视频链接](https://www.bilibili.com/video/BV19e4y1q7JJ/?spm_id_from=333.788.recommend_more_video.0)', '2023-06-04', NULL, '默认分类', 'github,git', 1, NULL);
INSERT INTO `t_article` VALUES (10, 'Android-Studio设置APP图标', '\r\n\r\n<meta name=\"referrer\" content=\"no-referrer\" />\r\n\r\n#### 在drawable中添加图片素材\r\n\r\n将图片拷贝到工程的`app\\src\\main\\res\\drawable`目录下\r\n\r\n#### 修改app默认的图标为指定图标\r\n\r\n![](http://typora-imagehost.oss-cn-guangzhou.aliyuncs.com/img/image-20230504172254525.png)\r\n\r\n在这里点击选择图片的路径\r\n\r\n![](http://typora-imagehost.oss-cn-guangzhou.aliyuncs.com/img/image-20230504172424245.png)\r\n\r\n前景页面的一些设置\r\n\r\n![](http://typora-imagehost.oss-cn-guangzhou.aliyuncs.com/img/image-20230504172655514.png)\r\n\r\n修改图标的背景颜色\r\n\r\n![](http://typora-imagehost.oss-cn-guangzhou.aliyuncs.com/img/image-20230504172759799.png)\r\n\r\n#### 在AndroidManifest.xml中选择\r\n\r\n![](http://typora-imagehost.oss-cn-guangzhou.aliyuncs.com/img/image-20230504172912129.png)\r\n\r\n![](http://typora-imagehost.oss-cn-guangzhou.aliyuncs.com/img/image-20230504173239218.png)', '2023-06-04', NULL, '默认分类', 'android', 1, NULL);
INSERT INTO `t_article` VALUES (11, 'Wsl安装', '\r\n<meta name=\"referrer\" content=\"no-referrer\" />\r\n\r\n### wsl安装\r\n\r\nWindows Subsystem for Linux，WSL，也就是Windows Linux子系统\r\n\r\n#### wsl介绍\r\n\r\n\r\n\r\n#### 安装过程\r\n\r\n##### 开启设置\r\n\r\n`win + s`搜索功能，点击启用或关闭Windows功能\r\n\r\n![](https://i.328888.xyz/2023/04/09/icVfr8.png)\r\n\r\n把适用于Linux的Windows子系统以及虚拟机平台勾选下，点击确定，之后电脑会安装东西，安装之后会出现重启选项\r\n\r\n![](http://typora-imagehost.oss-cn-guangzhou.aliyuncs.com/img/icVAZF.png)\r\n\r\n\r\n\r\n##### 下载\r\n\r\n在开启相应功能之后，可以直接去Microsoft Store搜索wsl安装相应的linux发行版，但是这样安装会安装到c盘。下面我们使用另一种安装方式，能安装到其他盘。\r\n\r\n先下载好相应的文件。\r\n\r\n相应的下载链接在\r\n\r\nhttps://learn.microsoft.com/zh-cn/windows/wsl/install-manual\r\n\r\n![](https://i.328888.xyz/2023/04/09/icVbOo.png)\r\n\r\n\r\n\r\n\r\n\r\n##### 解压\r\n\r\n将下载好的文件的扩展名改成.zip，然后解压到想安装的盘中。\r\n\r\n\r\n\r\n##### 运行\r\n\r\n点击exe，运行\r\n\r\n![](http://typora-imagehost.oss-cn-guangzhou.aliyuncs.com/img/image-20230409151346417.png)', '2023-06-04', NULL, '默认分类', 'wsl,linux', 1, NULL);
INSERT INTO `t_article` VALUES (13, 'ideavim的使用', '\r\n\r\n<meta name=\"referrer\" content=\"no-referrer\" />\r\n\r\n### 注意\r\n\r\n`[n]`：表示数字（不包括中括号）\r\n\r\n加粗的表示常用的\r\n\r\n\r\n\r\n### 基本操作\r\n\r\n#### 插入\r\n\r\n| 字母 |                  作用                  |\r\n| :--: | :------------------------------------: |\r\n| `i`  |        在光标之前，进入插入模式        |\r\n| `I`  |        在本行开头，进入插入模式        |\r\n| `a`  |        在光标之后，进入插入模式        |\r\n| `A`  |        在本行结尾，进入插入模式        |\r\n| `o`  |   在本行之后新增一行，并进入插入模式   |\r\n| `O`  |   在本行之前新增一行，并进入插入模式   |\r\n| `s`  |      删除当前字符，并进入插入模式      |\r\n| `S`  | 删除当前行中的所有文本，并进入插入模式 |\r\n\r\n#### 查找\r\n\r\n`[n]f{word}`：用来查找**当前行**当前光标后是否存在某个字符{word}，[n]代表第n个\r\n\r\n`t + 字母`：跳转到当前行内第一个匹配的字母前一个字符（按`:`可继续跳转至下一个）\r\n\r\n#### 移动\r\n\r\n- `ctrl+ u | ctrl + d`\r\n\r\n  `ctrl + u`：屏幕向上翻一页\r\n\r\n  `ctrl + d`：屏幕向下翻一页\r\n\r\n  \r\n\r\n- `0 | $ | ^`\r\n\r\n  `0`：移动到行首\r\n\r\n  `$`：跳转到该行的第一个字符\r\n\r\n  `^`：跳转到改行的最后一个字符\r\n\r\n- `%`：跳转到`()` `{}` `[]` (如果放在一个括号上，会跳转到匹配的括号上)\r\n\r\n- `[n]h/j/k/l`：比如20h表示向左移动20字符\r\n\r\n- `gg | G`\r\n\r\n  `gg`：移动到第一行\r\n\r\n  `G`：移动到最后一行\r\n\r\n- `H | M | L`\r\n\r\n  `H`：移动到当前页的第一行（head）\r\n\r\n  `M`：移动到编辑器中部（medium）\r\n\r\n  `L`：移动到当前页的最后一行（last）\r\n\r\n- `[n]w`：移动到后面单词的开始位置\r\n\r\n- `e`：移动到下一个词语的末尾（end）\r\n\r\n- `b`：移动到上一个单词的开头（begin）\r\n\r\n- **`zz`：将光标处文本移到屏幕中央**\r\n\r\n- `[n]`：输入数字加上enter，光标向下移动n行\r\n\r\n- `{ | }`：切换到段首\\尾部\r\n\r\n#### 替换、删除、撤销\r\n\r\n##### 替换\r\n\r\n`r`：输入r之后，再输入字符，就能进行替换了\r\n\r\n##### 删除\r\n\r\n###### c（change）\r\n\r\n**`caw/ciw`：删除当前单词，并进入插入模式**\r\n\r\n`cw`：在单词中只会删除后面的（比如光标在ch**a**nge在a，使用cw之后是ch）（dw则是删除之后不进入插入模式）\r\n\r\n**`cc`：删除当前行进入插入模式**\r\n\r\n**`caw`和`ciw`的区别：caw会删除单词周围的空格，而ciw不会**\r\n\r\n###### d（delete）\r\n\r\n`[n]dd`：删除光标所在的向下n行（常用dd删除当前行）\r\n\r\n`dG`：删除光标行及其以下行的全部内容(ggdG:删除全部)\r\n\r\n###### x\r\n\r\n`x`：删除光标处字符\r\n\r\n`X`：删除光标前面的字符\r\n\r\n##### 撤销\r\n\r\n`u`：撤销\r\n\r\n`ctrl + r`：回退上一步被撤销的操作\r\n\r\n`U`：回到当前行的初始状态\r\n\r\n\r\n\r\n#### 复制、粘贴\r\n\r\n##### 复制\r\n\r\n`\"+y`：复制内容到系统剪切板(注意要按三个键：\", +, y)\r\n\r\n`[n]yy`：复制光标所在的向下n行（常用yy复制当前行）\r\n\r\n**`yaw`：复制当前单词(aw：all words)**\r\n\r\n`y4j`：复制向下4行的内容(其他的也类似)\r\n\r\n`yfr`：复制到r的内容\r\n\r\n##### 粘贴\r\n\r\n`\"+p`：粘贴系统剪切板的内容\r\n\r\n`p`：将复制的数据在光标下一行贴上\r\n\r\n`P`：贴在上一行\r\n\r\n#### 格式化代码\r\n\r\n##### 自动格式化\r\n\r\n`==`：对光标所在行进行自动格式化对齐\r\n\r\n`gg=G`：对整个文件都格式化对齐\r\n\r\n`={motion}`：\r\n自动格式化 {motion} 操作前后的行。{motion} 可以是 vim 里面任意移动光标的操作。例如常见的 j、k、G、% 等。`%` 用于移动光标到匹配的括号上。当光标在 `{` 或者 `}`上时，`=%` 会格式化整个{}括起来的内容，包括 `{}` 自身\r\n\r\n- `=a{`\r\n  当光标所在行位于{}花括号内时，自动格式化对齐整个{}里面的内容，包括 `{}` 这两个花括号所在的行也会一起格式化，以 `{` 的上一行为基准来对齐。如果 `{` 自身的对齐错乱了，可以把 `{` 所在的行也一起对齐。\r\n- `=i{`\r\n  当光标所在行位于{}花括号内时，自动格式化对齐整个{}里面的内容，不包括 `{}` 这两个花括号所在的行，以 `{` 所在的行为基准来进行对齐。如果 `{` 自身所在行的对齐错乱，不会把 `{` 所在的行也一起对齐。\r\n\r\n##### 手动格式化\r\n\r\n`>>`：把光标所在行向右增加缩进\r\n\r\n`<<`：把光标所在行向左减少缩进\r\n\r\n类似的也有：`>{motion}`和`<{motion}`\r\n\r\n- `>a{`\r\n  当光标所在行位于{}花括号内时，将整个{}里面的内容向右增加缩进，包括 `{}` 这两个花括号所在的行也会一起缩进。\r\n- `>i{`\r\n  当光标所在行位于{}花括号内时，将整个{}里面的内容向右增加缩进，不包括 `{}` 这两个花括号所在的行，它们自身的行不会被缩进。\r\n\r\n#### 其他\r\n\r\n`J`：将光标所在行与下一行结合成同一行\r\n\r\n`ctrl + g`：显示文件信息\r\n\r\n`.`：重复上一次的操作\r\n\r\n#### 可视模式\r\n\r\n`v`，加上`h/j/k/l`可以选中文本\r\n\r\n`V`：选中整行\r\n\r\n`d`：删除选中文本\r\n\r\n`p`：复制选中文本\r\n\r\n`ggvG`：选中全部\r\n\r\n\r\n\r\n#### 底线模式\r\n\r\n按`/`或`:`进入底线模式\r\n\r\n##### 搜索/\r\n\r\n`/word`：向光标之下寻找一个叫word的字符串\r\n\r\n`?word`：与`/word`类似，不过是向上查找\r\n\r\n输入以上两条命令之后，按下enter之后：\r\n\r\n`n`：跳转下一个匹配结果\r\n\r\n`N`：跳转上一个匹配结果\r\n\r\n要想回到之前的光标处：`ctrl + o`\r\n\r\n去新的光标处：`ctrl + i`\r\n\r\n##### 替换:\r\n\r\n`:%s/source/target/g`：从第一行到最后一行寻找 word1 字符串，并将该字符串取代为 word2 ！(常用)\r\n\r\n- %s 全文搜索\r\n- source 代表要替换单词\r\n- target 代表替换的目标\r\n- /g 代表全文替换\r\n\r\n\r\n\r\n`:g/^\\s*$/d`： 删除空行以及只有空格的行\r\n\r\n##### 其他\r\n\r\n`:w`：保存文件\r\n\r\n`:[n]`：跳转到第n行\r\n\r\n\r\n\r\n---\r\n\r\n\r\n\r\n### 常用操作\r\n\r\n#### 有用的组合\r\n\r\nyaw	复制一个单词 （常用）\r\ndaw	删除一个单词 （常用）\r\ncaw	剪切一个单词到粘贴板，可利用 p 进行粘贴。（常用）\r\n\r\n#### 复制当前行并修改\r\n\r\n![](https://pic3.zhimg.com/v2-1fa451e9e90d883f45486173dc0b9d6e_b.webp)\r\n\r\n1. `yy` 复制当前行 `private String username;`\r\n2. `p` 将复制的内容进行粘贴\r\n3. `f;` 跳转到字符 `;` 处，这里其实就是相当于行位。\r\n4. `h` 向左移动一个光标\r\n5. `ciw` 删除当前处的词，并进入 `插入模式`\r\n6. `password` 输入 password 完成\r\n\r\n\r\n\r\n#### 删除多行\r\n\r\n![](https://pic3.zhimg.com/v2-23dfccdb03018da1ddf5ca1393fb50ba_b.jpg)\r\n\r\n1. `V` 进入内容选择模式（大V能选择整行）\r\n2. `kkk` 向上移动 3 行，并进行选中\r\n3. `d` 删除选中部分\r\n\r\n\r\n\r\n#### 删除特定内容\r\n\r\n**`di\"`删除`\"\"`内的内容(i是in)**\r\n\r\n若想删除之后立即进入插入模式，用`ci\"`\r\n\r\n![](https://pic3.zhimg.com/v2-23dfccdb03018da1ddf5ca1393fb50ba_b.webp)\r\n\r\n类似的，d替换成c可以立即进入插入模式\r\n\r\n`di(`删除`()`内的内容\r\n\r\n`di{`删除`{}`内的内容\r\n\r\n\r\n### .vimrc的配置\r\n\r\n#### 禁用方向键\r\n\r\n在插入模式和normal模式禁用\r\n[]map:映射命令(前面的中括号填模式)\r\n\r\n```\r\nimap <Up> <Nop> // 表示在插入模式中，将方向键上，<Nop>表示什么也不做\r\nnmao <Up> <Nop> // 表示在正常模式中\r\n\r\nimap <Down> <Nop>\r\nnmap <Down> <Nop>\r\n\r\nimap <Left> <Nop>\r\nnmap <Left> <Nop>\r\n\r\nimap <Right> <Nop>\r\nnmap <Right> <Nop>\r\n```\r\n\r\nctrl+j/ctrl+k移动4行, ctrl+u/ctrl+d移动9行（默认移动半屏）\r\n\r\n```\r\nnmap <C-j> 4j\r\nnmap <C-k> 4k\r\nnmap <C-u> 9k\r\nnmap <C-d> 9j\r\n```\r\n\r\n\r\n![](http://typora-imagehost.oss-cn-guangzhou.aliyuncs.com/img/itl.cat_vim-cheat-sheet-wallpaper_1026048.png)\r\n\r\nºº', '2023-06-04', NULL, '默认分类', 'idea,vim', 1, NULL);

-- ----------------------------
-- Table structure for t_authority
-- ----------------------------
DROP TABLE IF EXISTS `t_authority`;
CREATE TABLE `t_authority`  (
  `id` int(0) NOT NULL AUTO_INCREMENT,
  `authority` varchar(200) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT NULL COMMENT '权限',
  PRIMARY KEY (`id`) USING BTREE
) ENGINE = InnoDB AUTO_INCREMENT = 3 CHARACTER SET = utf8 COLLATE = utf8_general_ci ROW_FORMAT = Dynamic;

-- ----------------------------
-- Records of t_authority
-- ----------------------------
INSERT INTO `t_authority` VALUES (1, 'ROLE_admin');
INSERT INTO `t_authority` VALUES (2, 'ROLE_common');

-- ----------------------------
-- Table structure for t_comment
-- ----------------------------
DROP TABLE IF EXISTS `t_comment`;
CREATE TABLE `t_comment`  (
  `id` int(0) NOT NULL AUTO_INCREMENT COMMENT '评论id',
  `article_id` int(0) NOT NULL COMMENT '关联的文章id',
  `created` date NOT NULL COMMENT '评论时间',
  `ip` varchar(200) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT NULL COMMENT '评论用户登录的ip地址',
  `content` text CHARACTER SET utf8 COLLATE utf8_general_ci NOT NULL COMMENT '评论内容',
  `status` varchar(200) CHARACTER SET utf8 COLLATE utf8_general_ci NOT NULL DEFAULT 'approved' COMMENT '评论状态',
  `author` varchar(200) CHARACTER SET utf8 COLLATE utf8_general_ci NOT NULL COMMENT '评论用户用户名',
  PRIMARY KEY (`id`) USING BTREE
) ENGINE = InnoDB AUTO_INCREMENT = 15 CHARACTER SET = utf8 COLLATE = utf8_general_ci ROW_FORMAT = Dynamic;

-- ----------------------------
-- Records of t_comment
-- ----------------------------
INSERT INTO `t_comment` VALUES (2, 11, '2023-06-04', '0:0:0:0:0:0:0:1', '很不错的原理分析，受用了！', 'approved', '李四');
INSERT INTO `t_comment` VALUES (3, 10, '2023-06-04', '0:0:0:0:0:0:0:1', '关于Docker虚拟容器的讲解挺好的额，学习中', 'approved', '李四');
INSERT INTO `t_comment` VALUES (9, 1, '2023-06-04', '0:0:0:0:0:0:0:1', '非常不错，赞一个！', 'approved', '李四');
INSERT INTO `t_comment` VALUES (10, 1, '2023-06-04', '0:0:0:0:0:0:0:1', '博主，这资料怎么弄的？有相关资源和教材推荐吗？', 'approved', '李四');
INSERT INTO `t_comment` VALUES (11, 1, '2023-06-04', '0:0:0:0:0:0:0:1', '很详细，感谢...', 'approved', '东方不败');
INSERT INTO `t_comment` VALUES (12, 1, '2023-06-04', '0:0:0:0:0:0:0:1', '很全，努力学习中...', 'approved', '东方不败');
INSERT INTO `t_comment` VALUES (13, 1, '2023-06-04', '0:0:0:0:0:0:0:1', '好东西，先收藏起来，哈哈', 'approved', 'tom');
INSERT INTO `t_comment` VALUES (14, 8, '2023-06-04', '0:0:0:0:0:0:0:1', 'very good blog', 'approved', 'tom');

-- ----------------------------
-- Table structure for t_statistic
-- ----------------------------
DROP TABLE IF EXISTS `t_statistic`;
CREATE TABLE `t_statistic`  (
  `id` int(0) NOT NULL AUTO_INCREMENT,
  `article_id` int(0) NOT NULL COMMENT '关联的文章id',
  `hits` int(0) NOT NULL DEFAULT 0 COMMENT '文章点击总量',
  `comments_num` int(0) NOT NULL DEFAULT 0 COMMENT '文章评论总量',
  PRIMARY KEY (`id`) USING BTREE
) ENGINE = InnoDB AUTO_INCREMENT = 13 CHARACTER SET = utf8 COLLATE = utf8_general_ci ROW_FORMAT = Dynamic;

-- ----------------------------
-- Records of t_statistic
-- ----------------------------
INSERT INTO `t_statistic` VALUES (1, 1, 94, 5);
INSERT INTO `t_statistic` VALUES (2, 2, 3, 0);
INSERT INTO `t_statistic` VALUES (3, 3, 6, 0);
INSERT INTO `t_statistic` VALUES (4, 4, 4, 0);
INSERT INTO `t_statistic` VALUES (5, 5, 4, 0);
INSERT INTO `t_statistic` VALUES (6, 6, 15, 0);
INSERT INTO `t_statistic` VALUES (7, 7, 8, 0);
INSERT INTO `t_statistic` VALUES (8, 8, 28, 1);
INSERT INTO `t_statistic` VALUES (9, 9, 20, 0);
INSERT INTO `t_statistic` VALUES (10, 10, 20, 1);
INSERT INTO `t_statistic` VALUES (11, 11, 17, 1);
INSERT INTO `t_statistic` VALUES (13, 13, 7, 0);

-- ----------------------------
-- Table structure for t_user
-- ----------------------------
DROP TABLE IF EXISTS `t_user`;
CREATE TABLE `t_user`  (
  `id` int(0) NOT NULL AUTO_INCREMENT,
  `username` varchar(200) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT NULL,
  `password` varchar(200) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT NULL,
  `email` varchar(200) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT NULL,
  `created` date NULL DEFAULT NULL,
  `valid` tinyint(1) NOT NULL DEFAULT 1,
  PRIMARY KEY (`id`) USING BTREE
) ENGINE = InnoDB AUTO_INCREMENT = 5 CHARACTER SET = utf8 COLLATE = utf8_general_ci ROW_FORMAT = Dynamic;

-- ----------------------------
-- Records of t_user
-- ----------------------------
INSERT INTO `t_user` VALUES (1, 'admin', '$2a$10$5ooQI8dir8jv0/gCa1Six.GpzAdIPf6pMqdminZ/3ijYzivCyPlfK', '2127269781@qq.com', '2023-06-04', 1);
INSERT INTO `t_user` VALUES (2, '李四', '$2a$10$5ooQI8dir8jv0/gCa1Six.GpzAdIPf6pMqdminZ/3ijYzivCyPlfK', '1768653040@qq.com', '2023-06-04', 1);
INSERT INTO `t_user` VALUES (3, '东方不败', '$2a$10$5ooQI8dir8jv0/gCa1Six.GpzAdIPf6pMqdminZ/3ijYzivCyPlfK', '13718391550@163.com', '2023-06-04', 1);
INSERT INTO `t_user` VALUES (4, 'tom', '$2a$10$5ooQI8dir8jv0/gCa1Six.GpzAdIPf6pMqdminZ/3ijYzivCyPlfK', 'asexeees@sohu.com', '2023-06-04', 1);

-- ----------------------------
-- Table structure for t_user_authority
-- ----------------------------
DROP TABLE IF EXISTS `t_user_authority`;
CREATE TABLE `t_user_authority`  (
  `id` int(0) NOT NULL AUTO_INCREMENT,
  `user_id` int(0) NOT NULL COMMENT '关联的用户id',
  `authority_id` int(0) NOT NULL COMMENT '关联的权限id',
  PRIMARY KEY (`id`) USING BTREE
) ENGINE = InnoDB AUTO_INCREMENT = 5 CHARACTER SET = utf8 COLLATE = utf8_general_ci ROW_FORMAT = Dynamic;

-- ----------------------------
-- Records of t_user_authority
-- ----------------------------
INSERT INTO `t_user_authority` VALUES (1, 1, 1);
INSERT INTO `t_user_authority` VALUES (2, 2, 2);
INSERT INTO `t_user_authority` VALUES (3, 3, 2);
INSERT INTO `t_user_authority` VALUES (4, 4, 2);

SET FOREIGN_KEY_CHECKS = 1;
